---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mpookkot.
--- DateTime: 8/6/18 11:57 AM
---
function sysCall_init()
    local approachDirectionObstacle=sim.getObjectHandle('approachDirectionObstacle')
    local p=sim.getObjectSpecialProperty(approachDirectionObstacle)
    sim.setObjectMatrix(approachDirectionObstacle,-1,sim.buildIdentityMatrix())
    sim.setObjectSpecialProperty(approachDirectionObstacle,sim.boolOr32(p,sim.objectspecialproperty_collidable)-sim.objectspecialproperty_collidable)

end
getShiftedMatrix=function(matrix,v,absoluteShift)
    local m={}
    for i=1,12,1 do
        m[i]=matrix[i]
    end
    if absoluteShift then
        m[4]=m[4]+v[1]
        m[8]=m[8]+v[2]
        m[12]=m[12]+v[3]
    else
        m[4]=m[4]+m[1]*v[1]+m[2]*v[2]+m[3]*v[3]
        m[8]=m[8]+m[5]*v[1]+m[6]*v[2]+m[7]*v[3]
        m[12]=m[12]+m[9]*v[1]+m[10]*v[2]+m[11]*v[3]
    end
    return m
end

findCollisionFreeConfigAndCheckApproach=function(task)
    -- Here we search for a robot configuration..
    -- 1. ..that matches the desired pose (task.goalPose)
    -- 2. ..that does not collide in that configuration
    -- 3. ..that does not collide and that can perform the IK linear approach
    sim.setObjectMatrix(task.ikTarget,-1,task.goalPose)
    -- Here we check point 1 & 2:
    local c=sim.getConfigForTipPose(task.ikGroup,task.jh,0.65,20,nil,task.collisionPairs)
    if c then
        if task.approachVector[1]~=0 or task.approachVector[2]~=0 or task.approachVector[3]~=0 then
            -- Here we check point 3:
            local m=getShiftedMatrix(task.goalPose,task.approachVector,false)
            local path=generateIkPath(c,m,task)
            if path==nil then
                c=nil
            end
        end
    end
    return c
end

findSeveralCollisionFreeConfigsAndCheckApproach=function(task)
    -- Here we search for several robot configurations...
    -- 1. ..that matches the desired pose (task.goalPose)
    -- 2. ..that does not collide in that configuration
    -- 3. ..that does not collide and that can perform the IK linear approach
    sim.setObjectMatrix(task.ikTarget,-1,task.goalPose)
    local cs={}
    local l={}
    for i=1,task.maxTrialsForConfigSearch,1 do
        local c=findCollisionFreeConfigAndCheckApproach(task)
        if c then
            local dist=getConfigConfigDistance(task.currentState,c,task.metric)
            local p=0
            local same=false
            for j=1,#l,1 do
                if math.abs(l[j]-dist)<0.001 then
                    -- we might have the exact same config. Avoid that
                    same=true
                    for k=1,#task.jh,1 do
                        if math.abs(cs[j][k]-c[k])>0.01 then
                            same=false
                            break
                        end
                    end
                end
                if same then
                    break
                end
            end
            if not same then
                cs[#cs+1]=c
                l[#l+1]=dist
            end
        end
        if #l>=task.maxConfigsForDesiredPose then
            break
        end
    end
    if #cs==0 then
        cs=nil
    end
    return cs
end

getConfig=function(jointHandles)
    local config={}
    for i=1,#jointHandles,1 do
        config[i]=sim.getJointPosition(jointHandles[i])
    end
    return config
end

setConfig=function(jointHandles,config)
    if config then
        for i=1,#jointHandles,1 do
            sim.setJointPosition(jointHandles[i],config[i])
        end
    end
end

getConfigConfigDistance=function(config1,config2,metric)
    local d=0
    for i=1,#config1,1 do
        local dx=(config1[i]-config2[i])*metric[i]
        d=d+dx*dx
    end
    return math.sqrt(d)
end

getPathLength=function(path,metric)
    local d=0
    local l=#metric
    local pc=#path/l
    for i=1,pc-1,1 do
        local config1={path[(i-1)*l+1],path[(i-1)*l+2],path[(i-1)*l+3],path[(i-1)*l+4],path[(i-1)*l+5],path[(i-1)*l+6]}
        local config2={path[i*l+1],path[i*l+2],path[i*l+3],path[i*l+4],path[i*l+5],path[i*l+6]}
        d=d+getConfigConfigDistance(config1,config2,metric)
    end
    return d
end

findOnePath=function(task,goalConfigs)
    local omplTask=simOMPL.createTask('omplTask')
    simOMPL.setAlgorithm(omplTask,simOMPL.Algorithm.SBL)
    local j1_space=simOMPL.createStateSpace('j1_space',simOMPL.StateSpaceType.joint_position,task.jh[1],{-180*math.pi/180},{180*math.pi/180},1)
    local j2_space=simOMPL.createStateSpace('j2_space',simOMPL.StateSpaceType.joint_position,task.jh[2],{-90*math.pi/180},{150*math.pi/180},2)
    local j3_space=simOMPL.createStateSpace('j3_space',simOMPL.StateSpaceType.joint_position,task.jh[3],{-180*math.pi/180},{75*math.pi/180},3)
    local j4_space=simOMPL.createStateSpace('j4_space',simOMPL.StateSpaceType.joint_position,task.jh[4],{-400*math.pi/180},{400*math.pi/180},0)
    local j5_space=simOMPL.createStateSpace('j5_space',simOMPL.StateSpaceType.joint_position,task.jh[5],{-125*math.pi/180},{120*math.pi/180},0)
    local j6_space=simOMPL.createStateSpace('j6_space',simOMPL.StateSpaceType.joint_position,task.jh[6],{-400*math.pi/180},{400*math.pi/180},0)
    simOMPL.setStateSpace(omplTask,{j1_space,j2_space,j3_space,j4_space,j5_space,j6_space})
    simOMPL.setCollisionPairs(omplTask,task.collisionPairs)
    simOMPL.setStartState(omplTask,task.currentState)
    simOMPL.setGoalState(omplTask,goalConfigs[1])
    for i=2,#goalConfigs,1 do
        simOMPL.addGoalState(omplTask,goalConfigs[i])
    end
    simOMPL.setStateValidityCheckingResolution(omplTask,0.001)
    local path=nil
    local l=999999999999
    for i=1,task.searchCountPerConfig,1 do
        local res,_path=simOMPL.compute(omplTask,4,-1,task.minConfigsForPathPlanningPath)
        if res and _path then
            local _l=getPathLength(_path,task.metric)
            if _l<l then
                l=_l
                path=_path
            end
        end
    end
    simOMPL.destroyTask(omplTask)
    return path,l
end

findShortestPath=function(task,goalConfigs)
    -- This function will search for several paths between the specified start configuration,
    -- and several of the specified goal configurations. The shortest path will be returned
    local path=findOnePath(task,goalConfigs)
    return path
end

generateIkPath=function(startConfig,goalPose,task)
    -- Generates (if possible) a linear, collision free path between a robot config and a target pose
    local currentConfig=getConfig(task.jh)
    setConfig(task.jh,startConfig)
    sim.setObjectMatrix(task.ikTarget,-1,goalPose)
    local c=sim.generateIkPath(task.ikGroup,task.jh,task.minConfigsForIkPath,task.collisionPairs)
    setConfig(task.jh,currentConfig)
    return c
end

getReversedPath=function(path)
    local retPath={}
    local ptCnt=#path/6
    for i=ptCnt,1,-1 do
        for j=1,6,1 do
            retPath[#retPath+1]=path[(i-1)*6+j]
        end
    end
    return retPath
end

loadRobot=function(inInts,inFloats,inStrings,inBuffer)
    local baseHandle=sim.loadModel(inStrings[1])
    local p=sim.getObjectPosition(baseHandle,-1)
    p[1]=p[1]+inFloats[1]
    p[2]=p[2]+inFloats[2]
    p[3]=p[3]+inFloats[3]
    sim.setObjectPosition(baseHandle,-1,p)
    local o=sim.getObjectOrientation(baseHandle,-1)
    o[3]=o[3]+inFloats[4]
    sim.setObjectOrientation(baseHandle,-1,o)
    return {baseHandle},{},{},''
end

findPath_goalIsPose=function(inInts,inFloats,inStrings,inBuffer)
    local task={}
    task.robotHandle=inInts[1]
    local collisionChecking=inInts[2]>0
    task.minConfigsForIkPath=inInts[3]
    task.minConfigsForPathPlanningPath=inInts[4]
    task.maxConfigsForDesiredPose=inInts[5]
    task.maxTrialsForConfigSearch=inInts[6]
    task.searchCountPerConfig=inInts[7]

    local currentState={}
    for i=1,6,1 do currentState[i]=inFloats[i] end
    task.currentState=currentState
    local goalPose={}
    for i=1,12,1 do goalPose[i]=inFloats[i+6] end
    task.goalPose=goalPose
    local approachVector={}
    for i=1,3,1 do approachVector[i]=inFloats[i+6+12] end
    task.approachVector=approachVector

    local fullRobotName=sim.getObjectName(task.robotHandle)
    local suff,robotName=sim.getNameSuffix(fullRobotName)
    if suff==-1 then
        suff='#'
    else
        suff='#'..suff
    end

    local jh={-1,-1,-1,-1,-1,-1}
    for i=1,6,1 do
        jh[i]=sim.getObjectHandle('IRB4600_joint'..i..suff)
    end
    task.jh=jh

    task.ikGroup=sim.getIkGroupHandle('IRB4600'..suff)
    task.ikTip=sim.getObjectHandle('IRB4600_IkTip'..suff)
    task.ikTarget=sim.getObjectHandle('IRB4600_IkTarget'..suff)
    task.collisionPairs={sim.getCollectionHandle('IRB4600'..suff),sim.getCollectionHandle('not_IRB4600'..suff)}
    if not collisionChecking then
        task.collisionPairs={}
    end

    task.approachDirectionObstacle=sim.getObjectHandle('approachDirectionObstacle')
    task.metric={0.5,1,1,0.15,0.1,0.1}

    local configs=findSeveralCollisionFreeConfigsAndCheckApproach(task)
    if configs then
        local m=getShiftedMatrix(task.goalPose,{0,0,0.05},false)
        sim.setObjectMatrix(task.approachDirectionObstacle,-1,m)
        local p=sim.getObjectSpecialProperty(task.approachDirectionObstacle)
        sim.setObjectSpecialProperty(task.approachDirectionObstacle,sim.boolOr32(p,sim.objectspecialproperty_collidable))
        local path=findShortestPath(task,configs)
        sim.setObjectMatrix(task.approachDirectionObstacle,-1,sim.buildIdentityMatrix())
        sim.setObjectSpecialProperty(task.approachDirectionObstacle,sim.boolOr32(p,sim.objectspecialproperty_collidable)-sim.objectspecialproperty_collidable)

        if path then
            local fkTrajLength=#path/#jh
            local ikTrajLength=0
            if task.approachVector[1]~=0 or task.approachVector[2]~=0 or task.approachVector[3]~=0 then
                local currentConfig=getConfig(task.jh)
                local gc={}
                for i=1,#jh,1 do
                    gc[i]=path[#path-#jh+i]
                end
                setConfig(task.jh,gc)
                local m=sim.getObjectMatrix(task.ikTip,-1)
                m=getShiftedMatrix(m,task.approachVector)
                ikPath=generateIkPath(gc,m,task)
                if ikPath then
                    for i=1,#ikPath,1 do
                        path[#path+1]=ikPath[i]
                    end
                    ikTrajLength=#ikPath
                else
                    path={}
                    fkTrajLength=0
                    ikTrajLength=0
                end
                setConfig(task.jh,currentConfig)
            end
            return {fkTrajLength,ikTrajLength},path,{},''
        end
    end
    return {0,0},{},{},''
end

findPath_goalIsState=function(inInts,inFloats,inStrings,inBuffer)
    local task={}
    task.robotHandle=inInts[1]
    local collisionChecking=inInts[2]>0
    task.minConfigsForIkPath=2
    task.minConfigsForPathPlanningPath=inInts[3]
    task.searchCountPerConfig=inInts[4]

    local currentState={}
    for i=1,6,1 do currentState[i]=inFloats[i] end
    task.currentState=currentState
    local goalState={}
    for i=1,6,1 do goalState[i]=inFloats[6+i] end

    local fullRobotName=sim.getObjectName(task.robotHandle)
    local suff,robotName=sim.getNameSuffix(fullRobotName)
    if suff==-1 then
        suff='#'
    else
        suff='#'..suff
    end

    local jh={-1,-1,-1,-1,-1,-1}
    for i=1,6,1 do
        jh[i]=sim.getObjectHandle('IRB4600_joint'..i..suff)
    end
    task.jh=jh

    task.ikGroup=sim.getIkGroupHandle('IRB4600'..suff)
    task.ikTip=sim.getObjectHandle('IRB4600_IkTip'..suff)
    task.ikTarget=sim.getObjectHandle('IRB4600_IkTarget'..suff)
    task.collisionPairs={sim.getCollectionHandle('IRB4600'..suff),sim.getCollectionHandle('not_IRB4600'..suff)}
    if not collisionChecking then
        task.collisionPairs={}
    end

    task.approachDirectionObstacle=sim.getObjectHandle('approachDirectionObstacle')
    task.metric={0.5,1,1,0.15,0.1,0.1}

    local path=findShortestPath(task,{goalState})

    if path then
        return {#path},path,{},''
    end
    return {0},{},{},''
end

findIkPath=function(inInts,inFloats,inStrings,inBuffer)
    local task={}
    task.robotHandle=inInts[1]
    local collisionChecking=inInts[2]>0
    task.minConfigsForIkPath=inInts[3]
    local poseCnt=(#inFloats-6)/12
    local currentState={}
    for i=1,6,1 do currentState[i]=inFloats[i] end
    task.currentState=currentState
    local allGoalPoses={}
    for i=1,poseCnt,1 do
        local goalPose={}
        for j=1,12,1 do goalPose[j]=inFloats[12*(i-1)+6+j] end
        allGoalPoses[i]=goalPose
    end

    local fullRobotName=sim.getObjectName(task.robotHandle)
    local suff,robotName=sim.getNameSuffix(fullRobotName)
    if suff==-1 then
        suff='#'
    else
        suff='#'..suff
    end

    local jh={-1,-1,-1,-1,-1,-1}
    for i=1,6,1 do
        jh[i]=sim.getObjectHandle('IRB4600_joint'..i..suff)
    end
    task.jh=jh

    task.ikGroup=sim.getIkGroupHandle('IRB4600'..suff)
    task.ikTip=sim.getObjectHandle('IRB4600_IkTip'..suff)
    task.ikTarget=sim.getObjectHandle('IRB4600_IkTarget'..suff)
    task.collisionPairs={sim.getCollectionHandle('IRB4600'..suff),sim.getCollectionHandle('not_IRB4600'..suff)}
    if not collisionChecking then
        task.collisionPairs={}
    end

    local totalPath={}
    for posenb=1,#allGoalPoses,1 do
        goalPose=allGoalPoses[posenb]
        local path=generateIkPath(task.currentState,goalPose,task)
        if not path then
            return {0,0},{},{},''
        end
        local startInd=7
        if posenb==1 then startInd=1 end
        for i=startInd,#path,1 do
            totalPath[#totalPath+1]=path[i]
        end

        for i=1,6,1 do
            task.currentState[i]=path[#path-6+i]
        end
    end

    return {#totalPath,0},totalPath,{},''
end

runThroughPath=function(inInts,inFloats,inStrings,inBuffer)
    local robotHandle=inInts[1]
    local fullRobotName=sim.getObjectName(robotHandle)
    sim.setStringSignal(fullRobotName..'runPath',sim.packFloatTable(inFloats))
    return {},{},{},''
end

isRunningThroughPath=function(inInts,inFloats,inStrings,inBuffer)
    local robotHandle=inInts[1]
    local fullRobotName=sim.getObjectName(robotHandle)
    local ri=0
    if sim.getStringSignal(fullRobotName..'runPath') then
        ri=1
    end
    return {ri},{},{},''
end

visualizePath=function(inInts,inFloats,inStrings,inBuffer)
    local robotHandle=inInts[1]
    local r=inInts[2]
    local g=inInts[3]
    local b=inInts[4]
    local fullRobotName=sim.getObjectName(robotHandle)
    local suff,robotName=sim.getNameSuffix(fullRobotName)
    if suff==-1 then
        suff='#'
    else
        suff='#'..suff
    end
    local jh={-1,-1,-1,-1,-1,-1}
    for i=1,6,1 do
        jh[i]=sim.getObjectHandle('IRB4600_joint'..i..suff)
    end
    local ikTip=sim.getObjectHandle('IRB4600_IkTip'..suff)
    local currentConfig=getConfig(jh)
    local lineContainer=sim.addDrawingObject(sim.drawing_lines,2,0,-1,99999,nil,nil,nil,{r/255,g/255,b/255})
    for i=1,(#inFloats/#jh)-1,1 do
        for j=1,#jh,1 do
            sim.setJointPosition(jh[j],inFloats[(i-1)*#jh+j])
        end
        local tipPos=sim.getObjectPosition(ikTip,-1)
        for j=1,#jh,1 do
            sim.setJointPosition(jh[j],inFloats[i*#jh+j])
        end
        local tipPos2=sim.getObjectPosition(ikTip,-1)
        tipPos[4]=tipPos2[1]
        tipPos[5]=tipPos2[2]
        tipPos[6]=tipPos2[3]
        sim.addDrawingObjectItem(lineContainer,tipPos)
    end
    setConfig(jh,currentConfig)
    return {lineContainer},{},{},''
end

removeLine=function(inInts,inFloats,inStrings,inBuffer)
    sim.removeDrawingObject(inInts[1])
    return {},{},{},''
end

getRobotState=function(inInts,inFloats,inStrings,inBuffer)
    local robotHandle=inInts[1]
    local fullRobotName=sim.getObjectName(robotHandle)
    local suff,robotName=sim.getNameSuffix(fullRobotName)
    if suff==-1 then
        suff='#'
    else
        suff='#'..suff
    end
    local jh={-1,-1,-1,-1,-1,-1}
    local state={}
    for i=1,6,1 do
        jh[i]=sim.getObjectHandle('IRB4600_joint'..i..suff)
        state[i]=sim.getJointPosition(jh[i])
    end

    return {},state,{},''
end

getObjectPose=function(inInts,inFloats,inStrings,inBuffer)
    local objectHandle=inInts[1]
    local m=sim.getObjectMatrix(objectHandle,-1)
    return {},m,{},''
end

displayMessage=function(inInts,inFloats,inStrings,inBuffer)
    if _messageHandle then
        sim.endDialog(_messageHandle)
        _messageHandle=nil
    end
    if #inStrings>0 then
        _messageHandle=sim.displayDialog('Info',inStrings[1],sim.dlgstyle_message,false)
    end
    return {},{},{},''
end


